/**
 * Home page (Index)
 * Map area + bottom list + floating settings button
 */

import { ToiletCard } from '../components/ToiletCard';
import { ErrorBanner, BannerType } from '../components/ErrorBanner';
import { ToiletPoi, AppState, CallbackHandler, Callback0, Callback1, MinimalError, TravelMode } from '../common/types';
import { DEFAULT_CENTER, DEFAULT_ZOOM, DEFAULT_RADIUS_M } from '../common/config';
import { HarmonyGeo, LocationPermissionStatus, LocationAccuracy } from '../common/geo';
import { BaiduMapAdapter } from '../common/baiduMapAdapter';
import { LocalProvider } from '../common/localProvider';
import { AsyncCallback } from '@kit.BasicServicesKit';
import { openExternalNavigation, openNavigationWithPlanning } from '../common/navigation';
import { common } from '@kit.AbilityKit';
import router from '@ohos.router';
import { MapComponent, MapController, MapOptions, MapStatus } from '@bdmap/map';
import { LatLng, Initializer } from '@bdmap/base';
import { MapEvent } from '@bdmap/map/src/main/ets/e/h/g1/h1';

// å®šä¹‰å•æ‰€è·ç¦»ä¿¡æ¯æ¥å£
interface ToiletWithDistance {
  toilet: ToiletPoi;
  distance: number;
  estimatedTime: number;
}

@Entry
@Component
struct Index {
  @State appState: AppState = AppState.IDLE;
  @State myLocation: LatLng | null = null;
  @State toilets: ToiletPoi[] = [];
  @State loading: boolean = false;
  @State error?: string = undefined;
  @State bannerVisible: boolean = false;
  @State bannerMessage: string = '';
  @State bannerType: BannerType = BannerType.ERROR;
  @State selectedTime: number = 5; // é»˜è®¤5åˆ†é’Ÿ
  @State travelMode: TravelMode = TravelMode.WALKING; // é»˜è®¤æ­¥è¡Œ

  private geoService = HarmonyGeo.getInstance();
  private mapAdapter = new BaiduMapAdapter();
  private dataProvider = new LocalProvider();
  private mapOptions?: MapOptions; // ç™¾åº¦åœ°å›¾é€‰é¡¹
  private callback?: (err: Error | undefined, controller: MapController) => void; // ç™¾åº¦åœ°å›¾å›è°ƒ
  private mapController?: MapController; // ç™¾åº¦åœ°å›¾æ§åˆ¶å™¨
  private mapEventManager?: object; // ç™¾åº¦åœ°å›¾äº‹ä»¶ç®¡ç†å™¨

  aboutToAppear() {
    // ç¡®ä¿ç™¾åº¦åœ°å›¾SDKå·²ç»åˆå§‹åŒ–
    this.ensureBaiduSDKInitialized();
    
    this.initializeApp();

    // ç™¾åº¦åœ°å›¾åˆå§‹åŒ–é€‰é¡¹
    this.mapOptions = new MapOptions();
    
    // åˆ›å»ºåœ°å›¾çŠ¶æ€å¯¹è±¡ï¼Œè®¾ç½®ä¸­å¿ƒç‚¹å’Œç¼©æ”¾çº§åˆ«
    const mapStatus = new MapStatus({
      center: new LatLng(DEFAULT_CENTER.lat, DEFAULT_CENTER.lng),
      zoom: DEFAULT_ZOOM,
      rotate: 0,
      overlook: 0,
      ptOffset: [0, 0]
    });
    
    this.mapOptions.mapStatus = mapStatus;
    
    // æ‰‹åŠ¿æ§åˆ¶
    this.mapOptions.zoomGesturesEnabled = true;
    this.mapOptions.moveGesturesEnabled = true;
    this.mapOptions.rotateGesturesEnabled = true;
    this.mapOptions.overlookingGesturesEnabled = true;

    // ç™¾åº¦åœ°å›¾åˆå§‹åŒ–å›è°ƒ
    this.callback = async (err: Error | undefined, controller: MapController) => {
      if (!err && controller) {
        this.mapController = controller;
        this.mapAdapter.initialize(controller);

        try {
          // åœ°å›¾åŠ è½½å®Œæˆäº‹ä»¶
          const onLoad = () => {
            console.info('Index', 'Baidu map loaded successfully');
            // å¯ç”¨æˆ‘çš„ä½ç½®æ˜¾ç¤ºï¼Œæ˜¾ç¤ºè“è‰²å®šä½ç‚¹
            this.mapAdapter.setMyLocationEnabled(true);
            // å¦‚æœæœ‰ä½ç½®ä¿¡æ¯ï¼Œç§»åŠ¨åˆ°ç”¨æˆ·ä½ç½®å¹¶ç¡®ä¿å±…ä¸­
            if (this.myLocation) {
              // å»¶è¿Ÿä¸€ç‚¹æ—¶é—´ç¡®ä¿åœ°å›¾å®Œå…¨åŠ è½½ï¼Œç„¶åå±…ä¸­æ˜¾ç¤ºç”¨æˆ·ä½ç½®
              setTimeout(() => {
                this.mapAdapter.moveCamera(this.myLocation!, DEFAULT_ZOOM, true);
                console.info('Index: camera moved to user location after map load - ensuring centered');
              }, 500);
            }
          };
          
          // è®¾ç½®ç™¾åº¦åœ°å›¾äº‹ä»¶ç›‘å¬å™¨
          controller.addEventListener(MapEvent.MAPRENDERFINISH, onLoad);
          
        } catch (e) {
          console.warn('Index: bind map events failed', (e as Error).message || e);
        }

        // åˆå§‹ç›¸æœºä½ç½®
        const target = this.myLocation ?? DEFAULT_CENTER;
        this.mapAdapter.moveCamera(target, DEFAULT_ZOOM, false);
      } else {
        console.error('Index: map initialization failed', (err as Error)?.message || 'Unknown error');
        this.showError('åœ°å›¾åˆå§‹åŒ–å¤±è´¥');
      }
    };

    // è®¾ç½®åœ°å›¾ç‚¹å‡»ç›‘å¬å™¨
    try {
      this.mapAdapter.setOnMapClickListener((pos) => {
        const ctx = this.getUIContext().getHostContext() as common.UIAbilityContext;
        openNavigationWithPlanning(ctx, pos, 'Target', this.travelMode);
      });
      this.mapAdapter.setOnMarkerClickListener((_markerId, pos) => {
        const ctx = this.getUIContext().getHostContext() as common.UIAbilityContext;
        openNavigationWithPlanning(ctx, pos, 'Target', this.travelMode);
      });
    } catch (err) {
      console.warn('Index: register map listeners failed', (err as Error).message || err);
    }
  }

  build() {
    Stack() {
      // åœ°å›¾åŒºåŸŸä½œä¸ºèƒŒæ™¯
      this.buildMapArea()

      // æ‰¾å±æŒ‰é’®æ”¾åœ¨ä¸‹æ–¹
      Column() {
        Blank().layoutWeight(1)
        ToiletCard({
          loading: this.loading,
          onFindToiletClick: { handler: () => this.handleFindToilet() } as Callback0,
          onTimeChange: { handler: (time: number) => this.handleTimeChange(time) } as Callback1<number>,
          onModeChange: { handler: (mode: TravelMode) => this.handleModeChange(mode) } as Callback1<TravelMode>
        })
      }
      .width('100%')
      .height('100%')
      .zIndex(10)

      // æ‚¬æµ®çš„Bannerï¼Œä¸å½±å“åœ°å›¾å¸ƒå±€
      if (this.bannerVisible) {
        Column() {
          ErrorBanner({
            visible: this.bannerVisible,
            message: this.bannerMessage,
            type: this.bannerType,
            actionText: this.getActionText(),
            onActionClick: { handler: () => this.handleBannerAction() } as CallbackHandler,
            onClose: { handler: () => this.hideBanner() } as CallbackHandler
          })
          Blank()
        }
        .width('100%')
        .height('100%')
        .zIndex(30)
        .padding({ top: 12 })
      }

      // å·¦ä¸Šè§’è®¾ç½®æŒ‰é’®
      Column() {
        Button() {
          Image(('app.media.ic_settings'))
            .width(22)
            .height(22)
            .fillColor('#4C8BF5')
        }
        .width(44)
        .height(44)
        .backgroundColor(Color.White)
        .borderRadius(22)
        .shadow({ radius: 8, color: '#1A000000', offsetX: 0, offsetY: 2 })
        .onClick(() => {
          try {
            router.pushNamedRoute({ name: 'Settings' });
          } catch (err) {
          console.error('Index: navigate to settings failed', (err as Error).message || err);
        }
        })
        Blank()
      }
      .width('100%')
      .padding({ top: 12, left: 12 })
      .alignItems(HorizontalAlign.Start)
      .zIndex(20)

      // å³ä¸Šè§’å®šä½æŒ‰é’®
      Column() {
        Button() {
          Text('ğŸ“')
            .fontSize(20)
        }
        .width(44)
        .height(44)
        .backgroundColor(Color.White)
        .borderRadius(22)
        .shadow({ radius: 8, color: '#1A000000', offsetX: 0, offsetY: 2 })
        .onClick(() => {
          this.focusToMyLocation();
        })
        Blank()
      }
      .width('100%')
      .padding({ top: 12, right: 12 })
      .alignItems(HorizontalAlign.End)
      .zIndex(20)
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#F5F5F5')
  }

  @Builder
  buildMapArea() {
    MapComponent({
      onReady: this.callback,
      mapOptions: this.mapOptions
    })
      .width('100%')
      .height('100%')
  }

  private async initializeApp(): Promise<void> {
    try {
      this.appState = AppState.INIT;
      // ç™¾åº¦åœ°å›¾é€‚é…å™¨ä¸éœ€è¦initIfNeededè°ƒç”¨
      this.mapAdapter.moveCamera(DEFAULT_CENTER, DEFAULT_ZOOM);
      
      // ä¸»åŠ¨ç”³è¯·ä½ç½®æƒé™
      console.info('Index: requesting location permission on startup');
      const ctx = this.getUIContext().getHostContext() as common.UIAbilityContext;
      const granted = await this.geoService.requestLocationPermission(ctx);
      
      if (granted) {
        console.info('Index: location permission granted');
        // å¯ç”¨ç³»ç»Ÿçš„æˆ‘çš„ä½ç½®æ˜¾ç¤ºï¼Œä½†é€šè¿‡é…ç½®ç¦ç”¨æ§ä»¶æŒ‰é’®
        this.mapAdapter.setMyLocationEnabled(true);
        
        // è‡ªåŠ¨è·å–å½“å‰ä½ç½®å¹¶æ˜¾ç¤ºåœ¨åœ°å›¾ä¸Š
        try {
          console.info('Index: auto-locating user position');
          const location = await this.geoService.getCurrentLatLng({
            accuracy: LocationAccuracy.HIGH,
            timeout: 10000 // 10ç§’è¶…æ—¶
          });
          
          console.info('Index: auto-location successful:', location);
          this.myLocation = location;
          // ç¡®ä¿ç”¨æˆ·ä½ç½®å±…ä¸­æ˜¾ç¤º
          this.mapAdapter.moveCamera(location, DEFAULT_ZOOM, true);
          // ä¸æ¸…é™¤æ ‡è®°ï¼Œè®©ç³»ç»Ÿè“è‰²å®šä½ç‚¹å’Œè‡ªå®šä¹‰æ ‡è®°å…±å­˜
          // this.mapAdapter.clearMarkers();
          // this.mapAdapter.addMarker(location, 'æˆ‘çš„ä½ç½®', undefined, 'user_location');
          this.showInfo('å·²æ˜¾ç¤ºå®šä½ï¼Œåœ°å›¾å·²èšç„¦åˆ°æ‚¨çš„ä½ç½®');
        } catch (locationError) {
          console.warn('Index: auto-location failed:', locationError);
          // å®šä½å¤±è´¥ä¸å½±å“åº”ç”¨å¯åŠ¨ï¼Œåªæ˜¯ä¸æ˜¾ç¤ºå½“å‰ä½ç½®
        }
      } else {
        console.warn('Index: location permission denied');
      }
      
      this.appState = AppState.IDLE;
    } catch (error) {
      console.error('Index: initialize app failed', (error as Error).message || error);
      this.showError('åº”ç”¨åˆå§‹åŒ–å¤±è´¥');
    }
  }

  private async handleFindToilet(): Promise<void> {
    try {
      this.appState = AppState.LOCATING;
      this.loading = true;
      this.error = undefined;
      this.hideBanner();

      // è¿è¡Œæ—¶æƒé™ï¼šæ£€æŸ¥å¹¶ç”³è¯·å®šä½æƒé™ï¼ˆAPI 16ï¼‰
      const perm = await this.geoService.checkLocationPermission();
      if (perm !== LocationPermissionStatus.GRANTED) {
        console.info('Index: location permission not granted, requesting permission');
        const ctx = this.getUIContext().getHostContext() as common.UIAbilityContext;
        const granted = await this.geoService.requestLocationPermission(ctx);
        if (!granted) {
          console.warn('Index: user denied location permission');
          this.showPermissionError();
          throw new Error('LOCATION_PERMISSION_DENIED');
        }
        console.info('Index: location permission granted by user');
      }

      // è·å–å½“å‰ä½ç½®
      console.info('Index: getting current location for toilet search');
      let currentLocation: LatLng;
      
      try {
        currentLocation = await this.geoService.getCurrentLatLng({
          accuracy: LocationAccuracy.HIGH,
          timeout: 15000 // 15ç§’è¶…æ—¶
        });
        console.info('Index: current location obtained:', currentLocation);
        this.myLocation = currentLocation;
        
        // ç¡®ä¿å½“å‰ä½ç½®åœ¨åœ°å›¾ä¸­å¿ƒ
        console.info('Index: centering map to current location');
        this.mapAdapter.moveCamera(currentLocation, DEFAULT_ZOOM, true);
      } catch (locationError) {
         console.error('Index: failed to get current location:', locationError);
         this.appState = AppState.ERROR;
         this.showError('å®šä½å¤±è´¥ï¼Œè¯·æ£€æŸ¥GPSè®¾ç½®æˆ–ç½‘ç»œè¿æ¥');
         return;
       }
      // å¯ç”¨ç³»ç»Ÿçš„æˆ‘çš„ä½ç½®æ˜¾ç¤ºï¼Œæ˜¾ç¤ºè“è‰²å®šä½ç‚¹
      this.mapAdapter.setMyLocationEnabled(true);
      // æ¸…é™¤å•æ‰€æ ‡è®°ï¼Œä½†ä¿ç•™ç³»ç»Ÿè“è‰²å®šä½ç‚¹
      this.mapAdapter.clearMarkers();

      // æœç´¢é™„è¿‘å•æ‰€
      this.appState = AppState.SEARCHING;
      
      // ä½¿ç”¨LocalProvideræœç´¢é™„è¿‘å•æ‰€
      console.info('Index: searching toilets near location:', currentLocation);
      const toilets = await this.dataProvider.searchToilets({
        center: currentLocation,
        radiusM: DEFAULT_RADIUS_M,
        limit: 20
      });
      console.info('Index: found toilets:', toilets.length);
      
      if (toilets.length === 0) {
        this.appState = AppState.EMPTY;
        this.showError('é™„è¿‘æ²¡æœ‰æ‰¾åˆ°å•æ‰€');
        return;
      }
      
      // æ ¹æ®é€‰æ‹©çš„æ—¶é•¿ç­›é€‰æœ€è¿‘çš„å•æ‰€
      const nearestToilet = await this.findNearestToiletWithinTime(currentLocation, toilets);
      
      if (!nearestToilet) {
        this.showError(`åœ¨${this.selectedTime}åˆ†é’Ÿå†…æœªæ‰¾åˆ°å¯è¾¾å•æ‰€`);
        return;
      }
      
      // æ¸²æŸ“ç»“æœ
      this.appState = AppState.RENDERING;
      this.toilets = toilets;
      
      // æ·»åŠ å•æ‰€æ ‡è®°ï¼Œé«˜äº®æœ€è¿‘çš„å•æ‰€
      toilets.forEach(toilet => {
        const isNearest = toilet.id === nearestToilet.id;
        this.mapAdapter.addMarker(toilet, toilet.name);
      });
      
      // è‡ªåŠ¨å¯¼èˆªåˆ°æœ€è¿‘çš„å•æ‰€
      console.info('Index: navigating to nearest toilet:', nearestToilet);
      const ctx = this.getUIContext().getHostContext() as common.UIAbilityContext;
      openNavigationWithPlanning(
        ctx, 
        nearestToilet, 
        nearestToilet.name, 
        this.travelMode
      );
      
      this.appState = AppState.IDLE;
      const modeText = this.travelMode === TravelMode.WALKING ? 'æ­¥è¡Œ' : 'éª‘è¡Œ';
      this.showInfo(`å·²ä¸ºæ‚¨è§„åˆ’${modeText}è·¯çº¿åˆ°"${nearestToilet.name}"`);
      
   } catch (error) {
      console.error('Index: handleFindToilet failed', (error as Error).message || error);
      this.appState = AppState.ERROR;
      const appErr = error as MinimalError;
      const code: string = appErr.code ?? '';
      const msg: string = appErr.message ?? '';
      if (code.includes('PERMISSION')) {
        this.showPermissionError();
      } else if (code.includes('TIMEOUT') || msg.includes('è¶…æ—¶')) {
        this.showError('å®šä½è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
      } else {
        this.showError('æœç´¢å¤±è´¥ï¼Œè¯·é‡è¯•');
      }
    } finally {
      this.loading = false;
    }
  }

  private async findNearestToiletWithinTime(currentLocation: LatLng, toilets: ToiletPoi[]): Promise<ToiletPoi | null> {
    if (toilets.length === 0) {
      return null;
    }

    // è®¡ç®—æ¯ä¸ªå•æ‰€çš„è·ç¦»å’Œé¢„ä¼°æ—¶é—´
    const toiletsWithTime = toilets.map(toilet => {
      // è®¡ç®—ç›´çº¿è·ç¦»ï¼ˆç±³ï¼‰
      const distance = this.calculateDistance(currentLocation, toilet);
      
      // æ ¹æ®å‡ºè¡Œæ–¹å¼ä¼°ç®—æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
      let estimatedTime: number;
      if (this.travelMode === TravelMode.WALKING) {
        // æ­¥è¡Œé€Ÿåº¦çº¦ 5 km/h = 83.33 m/min
        estimatedTime = distance / 83.33;
      } else {
        // éª‘è¡Œé€Ÿåº¦çº¦ 15 km/h = 250 m/min
        estimatedTime = distance / 250;
      }
      
      return {
        toilet,
        distance,
        estimatedTime
      } as ToiletWithDistance;
    });

    // ç­›é€‰åœ¨æŒ‡å®šæ—¶é—´å†…å¯è¾¾çš„å•æ‰€
    const reachableToilets = toiletsWithTime.filter(item => item.estimatedTime <= this.selectedTime);
    
    if (reachableToilets.length === 0) {
      return null;
    }

    // è¿”å›è·ç¦»æœ€è¿‘çš„å•æ‰€
    const nearest = reachableToilets.reduce((prev, current) => 
      prev.distance < current.distance ? prev : current
    );
    
    return nearest.toilet;
  }

  private calculateDistance(pos1: LatLng, pos2: LatLng | ToiletPoi): number {
    const R = 6371000; // åœ°çƒåŠå¾„ï¼ˆç±³ï¼‰
    const lat1Rad = pos1.lat * Math.PI / 180;
    const lat2Rad = pos2.lat * Math.PI / 180;
    const deltaLatRad = (pos2.lat - pos1.lat) * Math.PI / 180;
    const deltaLngRad = (pos2.lng - pos1.lng) * Math.PI / 180;

    const a = Math.sin(deltaLatRad / 2) * Math.sin(deltaLatRad / 2) +
              Math.cos(lat1Rad) * Math.cos(lat2Rad) *
              Math.sin(deltaLngRad / 2) * Math.sin(deltaLngRad / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c; // è¿”å›è·ç¦»ï¼ˆç±³ï¼‰
  }

  private handleToiletItemClick(toilet: ToiletPoi): void {
    try {
      this.mapAdapter.moveCamera(toilet, DEFAULT_ZOOM);
      const ctx = this.getUIContext().getHostContext() as common.UIAbilityContext;
      openNavigationWithPlanning(ctx, toilet, toilet.name, this.travelMode);
    } catch (error) {
      console.error('Index: move to toilet location failed', (error as Error).message || error);
    }
  }

  private handleTimeChange(time: number): void {
    this.selectedTime = time;
    console.info('Index', `Time changed to ${time} minutes`);
  }

  private handleModeChange(mode: TravelMode): void {
    this.travelMode = mode;
    const modeText = mode === TravelMode.WALKING ? 'æ­¥è¡Œ' : 'éª‘è¡Œ';
    console.info('Index', `Travel mode changed to ${modeText}`);
    this.showInfo(`å·²åˆ‡æ¢åˆ°${modeText}æ¨¡å¼`);
  }

  private showPermissionError(): void {
    this.bannerType = BannerType.ERROR;
    this.bannerMessage = 'å®šä½æƒé™è¢«æ‹’ç»ï¼Œè¯·åœ¨è®¾ç½®ä¸­å¼€å¯ä½ç½®æƒé™ä»¥ä½¿ç”¨å®šä½åŠŸèƒ½';
    this.bannerVisible = true;
  }

  private showError(message: string): void {
    this.error = message;
    this.bannerType = BannerType.ERROR;
    this.bannerMessage = message;
    this.bannerVisible = true;
  }

  private showInfo(message: string): void {
    this.bannerType = BannerType.INFO;
    this.bannerMessage = message;
    this.bannerVisible = true;
  }

  private hideBanner(): void {
    this.bannerVisible = false;
    this.error = undefined;
  }

  private focusToMyLocation(): void {
    if (this.myLocation) {
      // å¦‚æœå·²æœ‰å®šä½ä¿¡æ¯ï¼Œç›´æ¥èšç„¦åˆ°è¯¥ä½ç½®å¹¶ç¡®ä¿å±…ä¸­
      console.info('Index: focusing to my location:', this.myLocation);
      this.mapAdapter.moveCamera(this.myLocation, DEFAULT_ZOOM, true);
      // ç¡®ä¿ç”¨æˆ·ä½ç½®æ ‡è®°å¯è§å¹¶å±…ä¸­
      this.mapAdapter.clearMarkers();
      this.mapAdapter.addMarker(this.myLocation, 'æˆ‘çš„ä½ç½®', undefined, 'user_location');
      this.showInfo('å·²èšç„¦åˆ°æ‚¨çš„ä½ç½®');
    } else {
      // å¦‚æœæ²¡æœ‰å®šä½ä¿¡æ¯ï¼Œé‡æ–°è·å–ä½ç½®
      console.info('Index: no location available, requesting new location');
      this.handleFindToilet();
    }
  }

  private getActionText(): string | undefined {
    return (this.bannerType === BannerType.WARNING || this.bannerType === BannerType.ERROR) ? 'Retry' : undefined;
  }

  private handleBannerAction(): void {
    this.hideBanner();
    if (this.bannerType === BannerType.WARNING || this.bannerType === BannerType.ERROR) {
      this.handleFindToilet();
    }
  }

  /**
   * ç¡®ä¿ç™¾åº¦åœ°å›¾SDKå·²ç»åˆå§‹åŒ–
   */
  private ensureBaiduSDKInitialized(): void {
    try {
      const initializer = Initializer.getInstance();
      const context = this.getUIContext().getHostContext() as common.UIAbilityContext;
      initializer.initialize("xTn4vwunlUWLWilFpx5QcDUOycbq34YZ", context.getApplicationContext());
      console.info('Index: Baidu SDK re-initialized to ensure availability');
    } catch (error) {
      console.warn('Index: Baidu SDK initialization check failed:', error);
    }
  }
}



