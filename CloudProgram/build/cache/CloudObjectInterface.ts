/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2024. All rights reserved.
 * Generated by the Cloud Object compiler. DO NOT EDIT!
 */

import * as ts from "typescript";
import {factory, MethodSignature, Node, PropertySignature} from "typescript";
import * as fs from "fs";
import * as path from "path";

// const exportDir = './'
const extensionName = `.ts`;

const callFunctionUtil = 'CallFunctionUtil';

const callMethod = 'call';

let importObjectName = 'ImportObject';

let cloudObjectMethods: MethodSignature[] = [];

const printer = createPrinter();

let printLog = false;

const useCallFunction = false;

// Parsing the dependency tree
class Context {
    declaration: Map<string, string>;
}

// cloud object文件夹
let functionPath = process.argv[2];
// 检查输入
checkIsDirectory(functionPath);
let cloudObjectName = path.basename(functionPath);
console.info(`cloud object: ${cloudObjectName}`);

// 指定生成ts目录
const exportDir = process.argv[3];
// 检查输入
checkIsDirectory(exportDir);
// 指定生成.d.ts目录
const declarationDir = path.join(exportDir, 'declarationDir');

// 解析function-config
let [moduleName, handler] = parseFunctionConfig(functionPath);
let cloudObjectPath = '';
if (path.basename(exportDir) == 'cloud_objects') {
    // 指向的路径是cloud_objects har包
    cloudObjectPath = path.join(exportDir, 'src/main/ets');
} else {
    // 指向其它路径
    cloudObjectPath = path.join(exportDir, 'cloudobject');
}
const basePath = path.join(cloudObjectPath, cloudObjectName);
// 生成.d.ts申明文件
let cloudFunctionEntryPath = path.join(functionPath, moduleName + '.ts');
console.info(`cloudFunctionEntryPath: ${cloudFunctionEntryPath}`);
emitDeclaration(declarationDir);
let handlerDts = path.join(declarationDir, moduleName + '.d.ts');
console.info(`handler dts ${handlerDts}`);
// 解析申明文件，生成云对象调用接口
parseDts(handlerDts, {declaration: new Map<string, string>()});

if (useCallFunction) {
    createCallFunctionUtil(callFunctionUtil);
} else {
    createImportObject(importObjectName);
}

// 删除.d.ts申明文件
removeDir(declarationDir);

// 修改Index.ets，增加export
writeIndex();

console.log(`The Invoke Interface for CloudObject: ${cloudObjectName} generated in directory: ${path.resolve(cloudObjectPath)} successfully.`);

function writeIndex() {
    let indexPath = path.join(exportDir, 'Index.ets');
    if (!fs.existsSync(indexPath)) {
        return;
    }
    let sourceCode = fs.readFileSync(indexPath, 'utf-8');
    let exportImportObject = `export { importObject } from './src/main/ets/ImportObject';`;
    if (!sourceCode.includes(exportImportObject)) {
        sourceCode = sourceCode + '\n' + exportImportObject;
    }
    let exportCode = `export { ${handler} } from './src/main/ets/${cloudObjectName}/${moduleName}';`;
    if (sourceCode.includes(exportCode)) {
        return;
    }
    sourceCode = sourceCode + '\n' + exportCode;
    writeFileSync(indexPath, sourceCode);
}

function writeFileSync(callFunctionFile: string, content: string) {
    console.log(`------ writeFileSync ${callFunctionFile} ------\n`);
    console.log(`${content}`);
    fs.writeFileSync(callFunctionFile, content);
}

function createCallFunctionUtil(fileName) {
    let callFunctionFile = path.join(basePath, fileName + '.ts');
    let content = '';
    if (printLog) {
        let callFunctionPrintLog: string[] = [`import hilog from '@ohos.hilog';\n`,
            `hilog.debug(0x0000, 'callFunction', 'input: '+ JSON.stringify(input));`,
            `hilog.debug(0x0000, 'callFunction', 'response: ' + JSON.stringify(res.getValue()));\n            `
        ];
        content += getCallFunctionModule(getMethods(), callFunctionPrintLog);
    } else {
        content += getCallFunctionModule(getMethods());
    }

    writeFileSync(callFunctionFile, content);
}

function createImportObject(fileName) {
    let callFunctionFile = path.join(cloudObjectPath, fileName + extensionName);
    let print = printLog ? `console.log('callFunction input: ' + JSON.stringify(input));\n` : '';
    let content = getImportObjectModule(print);
    writeFileSync(callFunctionFile, content);
}

function emitDeclaration(declarationDir: string) {
    compileCloudFunction(cloudFunctionEntryPath, {
        allowJs: true,
        declaration: true,
        emitDeclarationOnly: true,
        skipLibCheck: true,
        declarationDir: declarationDir
    });
}

function compileCloudFunction(entry: string, options: ts.CompilerOptions) {
    // Create a Program with an in-memory emit
    const dts = {}
    const host = ts.createCompilerHost(options);
    // Prepare and emit the d.ts files
    const program = ts.createProgram([entry], options, host);
    program.emit();
    return dts;
}

function writeFile(file: string, content: string) {
    let cloudObjectEtsDir = path.join(basePath, path.relative(declarationDir, path.dirname(file)));
    if (!fileExists(cloudObjectEtsDir)) {
        fs.mkdirSync(cloudObjectEtsDir, {recursive: true});
    }
    let writeFileName = path.join(cloudObjectEtsDir, path.basename(file, '.d.ts') + extensionName);
    writeFileSync(writeFileName, content);
}

function analyzeDependency(node: ts.ImportDeclaration, file: string, context: Context) {
    // 递归分析依赖树，如果有依赖三方包的报错
    node.forEachChild(importDeclarationChild => {
        if (ts.isStringLiteral(importDeclarationChild)) {
            let text = importDeclarationChild.text;
            if (!text.startsWith('.')) {
                console.error(`Dependency Error! Can not have third-party dependencies!`);
                console.error(`Dependency Error! file: ${file} import third-party dependency: ${text}`);
                process.exit(100);
            }
            let dirname = path.dirname(file);
            if (!fileExists(dirname)) {
                console.error(`Dependency Error! can't find ${dirname}`);
                process.exit(100);
            }
            let dependency = path.join(dirname, text + '.d.ts');
            // 防止循环依赖
            if (!context.declaration.get(dependency)) {
                console.log(`file ${file} import ${dependency}`);
                parseDts(dependency, context);
            }
        }
    });
}

function modifyDeclaredHandlerClass(node: ts.ClassDeclaration, printer: ts.Printer, sourceFile: ts.SourceFile) {
    let publicMethods: MethodSignature[] = cloudObjectMethods;
    for (const member of node.members) {
        // 过滤method以外的member
        if (ts.isMethodDeclaration(member)) {
            // 过滤掉包含modifiers的函数申明，只取public的method
            if (!member.modifiers || member.modifiers.length == 0) {
                let myType = member.type;
                let isPromise = false;
                // 因为端侧云函数是异步接口，所以返回值如果不是Promise类型，就用Promise包装
                if (ts.isTypeReferenceNode(myType)) {
                    if (ts.isIdentifier(myType.typeName)) {
                        if (myType.typeName.escapedText === "Promise") {
                            isPromise = true;
                        }
                    }
                }
                if (!isPromise) {
                    myType = factory.createTypeReferenceNode(
                        factory.createIdentifier("Promise"),
                        [member.type]
                    )
                }

                publicMethods.push(factory.createMethodSignature(
                    undefined,
                    member.name,
                    member.questionToken,
                    member.typeParameters,
                    member.parameters,
                    myType
                ));
            }
        }
    }
    let interfaceDeclaration = factory.createInterfaceDeclaration(
        [...node.modifiers.filter(modify => modify.kind != ts.SyntaxKind.DeclareKeyword)],
        node.name,
        undefined,
        undefined,
        publicMethods
    );
    return printer.printNode(ts.EmitHint.Unspecified, interfaceDeclaration, sourceFile);
}

function modifyDeclaredDependenceClass(node: ts.ClassDeclaration, printer: ts.Printer, sourceFile: ts.SourceFile) {
    let publicProperties: PropertySignature[] = [];
    for (const member of node.members) {
        // 过滤property以外的member
        if (ts.isPropertyDeclaration(member)) {
            // 过滤掉包含modifiers的property申明，只取public的property
            if (!member.modifiers || member.modifiers.length == 0) {
                publicProperties.push(factory.createPropertySignature(undefined,
                    member.name,
                    member.questionToken,
                    member.type
                ));
            }
        }
    }
    let declaredDependenceClass = factory.createInterfaceDeclaration(
        [...node.modifiers.filter(modify => modify.kind != ts.SyntaxKind.DeclareKeyword)],
        node.name,
        undefined,
        undefined,
        publicProperties
    );
    return printer.printNode(ts.EmitHint.Unspecified, declaredDependenceClass, sourceFile);
}

function createPrinter() {
    return ts.createPrinter({newLine: ts.NewLineKind.LineFeed});
}

function createFilterPrinter() {
    let isCloudObject = false;
    let isDependencyClass = false;
    return ts.createPrinter({newLine: ts.NewLineKind.LineFeed}, {
        onEmitNode(hint, node, emitCallback) {
            if (ts.isClassDeclaration(node)) {
                // 云对象export class只提取method，云对象依赖类型只提取public Property
                if (node.name.text === handler) {
                    isCloudObject = true
                    emitCallback(hint, node);
                    isCloudObject = false;
                } else {
                    isDependencyClass = true
                    emitCallback(hint, node);
                    isDependencyClass = false;
                }
            } else if (ts.isPropertyDeclaration(node)) {
                if (isDependencyClass) {
                    if (!node.modifiers) {
                        emitCallback(hint, node);
                    }
                }
            } else if (ts.isMethodDeclaration(node)) {
                if (isCloudObject) {
                    emitCallback(hint, node);
                }
            } else if (ts.isConstructorDeclaration(node)) {
                // ignore constructor
            } else {
                emitCallback(hint, node);
            }
        }
    });
}

function isCloudObjectEntryModule(file: string) {
    return path.basename(file, '.d.ts') === moduleName;
}

function getText(node: Node) {
    return printer.printNode(ts.EmitHint.Unspecified, node, undefined);
}

function getMethods() {
    let result = [];
    for (const method of cloudObjectMethods) {
        result.push(getText(method.name))
    }

    return '\'' + result.join('\' | \'') + '\'';
}

// 实现cloud object
function generateImplementation() {
    let members = [];
    for (const method of cloudObjectMethods) {
        let properties = [
            factory.createPropertyAssignment(
                factory.createIdentifier("method"),
                factory.createNoSubstitutionTemplateLiteral(
                    getText(method.name),
                    getText(method.name)
                )
            )
        ];
        if (method.parameters && method.parameters.length != 0) {
            let elements = [];
            for (const parameter of method.parameters) {
                elements.push(factory.createIdentifier(getText(parameter.name)));
            }

            properties.push(factory.createPropertyAssignment(
                factory.createIdentifier("params"),
                factory.createArrayLiteralExpression(
                    elements,
                    false
                )
            ))
        }
        let methodDeclaration = factory.createMethodDeclaration(
            undefined,
            undefined,
            method.name,
            undefined,
            undefined,
            method.parameters,
            method.type,
            factory.createBlock(
                [factory.createReturnStatement(factory.createAsExpression(
                    factory.createCallExpression(
                        factory.createIdentifier(callMethod),
                        undefined,
                        [factory.createObjectLiteralExpression(
                            properties,
                            true
                        )]
                    ),
                    method.type
                ))],
                true
            )
        );
        members.push(methodDeclaration);
    }
    let cloudObjectImpl = factory.createClassDeclaration(
        [factory.createToken(ts.SyntaxKind.ExportKeyword)],
        factory.createIdentifier(`${handler}Impl`),
        undefined,
        [factory.createHeritageClause(
            ts.SyntaxKind.ImplementsKeyword,
            [factory.createExpressionWithTypeArguments(
                factory.createIdentifier(handler),
                undefined
            )]
        )],
        members
    );
    return printer.printNode(ts.EmitHint.Unspecified, cloudObjectImpl, undefined);
}

function exportInstance() {
    let exportInstanceNode = factory.createVariableStatement(
        [factory.createToken(ts.SyntaxKind.ExportKeyword)],
        factory.createVariableDeclarationList(
            [factory.createVariableDeclaration(
                factory.createIdentifier(`${handler}`.toLowerCase()),
                undefined,
                factory.createTypeReferenceNode(
                    factory.createIdentifier(`${handler}`),
                    undefined
                ),
                factory.createNewExpression(
                    factory.createIdentifier(`${handler}Impl`),
                    undefined,
                    []
                )
            )],
            ts.NodeFlags.Let
        )
    );

    return printer.printNode(ts.EmitHint.Unspecified, exportInstanceNode, undefined);
}

function generateImplementationClass(node: ts.ClassDeclaration, sourceFile: ts.SourceFile) {
    let publicMethods = [];
    for (const member of node.members) {
        // 过滤method以外的member
        if (ts.isMethodDeclaration(member)) {
            // 过滤掉包含modifiers的函数申明，只取public的method
            if (!member.modifiers || member.modifiers.length == 0) {
                let myType = member.type;
                let isPromise = false;
                // 因为端侧云函数是异步接口，所以返回值如果不是Promise类型，就用Promise包装
                if (ts.isTypeReferenceNode(myType)) {
                    if (ts.isIdentifier(myType.typeName)) {
                        if (myType.typeName.escapedText === "Promise") {
                            isPromise = true;
                        }
                    }
                }
                if (!isPromise) {
                    myType = factory.createTypeReferenceNode(
                        factory.createIdentifier("Promise"),
                        [member.type]
                    )
                }

                let addMethod = factory.createMethodDeclaration(
                    [factory.createModifier(ts.SyntaxKind.PublicKeyword), factory.createModifier(ts.SyntaxKind.AsyncKeyword)],
                    undefined,
                    member.name.getText(sourceFile),
                    member.questionToken,
                    member.typeParameters,
                    member.parameters,
                    myType,
                    factory.createBlock(
                        [factory.createReturnStatement(factory.createCallExpression(
                            factory.createPropertyAccessExpression(
                                factory.createIdentifier("Promise"),
                                factory.createIdentifier("reject")
                            ),
                            undefined,
                            [factory.createNewExpression(
                                factory.createIdentifier("Error"),
                                undefined,
                                [factory.createStringLiteral("Method not implemented.", true)]
                            )]
                        ))],
                        true
                    )
                );
                const leadingComments = ts.getCommentRange(member);
                publicMethods.push(ts.setCommentRange(addMethod, leadingComments));
            }
        }
    }

    let interfaceImpl = factory.createClassDeclaration(
        [...node.modifiers.filter(modify => modify.kind != ts.SyntaxKind.DeclareKeyword)],
        node.name,
        undefined,
        [factory.createHeritageClause(
            ts.SyntaxKind.ImplementsKeyword,
            [factory.createExpressionWithTypeArguments(
                factory.createIdentifier("CloudObjectLikely"),
                undefined
            )]
        )],
        [factory.createPropertyDeclaration(
            [factory.createModifier(ts.SyntaxKind.PublicKeyword)],
            factory.createIdentifier("name",),
            undefined,
            undefined,
            factory.createStringLiteral(cloudObjectName, true)
        ),
            ...publicMethods]
    )

    return printer.printNode(ts.EmitHint.Unspecified, interfaceImpl, sourceFile);
}

function parseDts(file: string, context: Context): void {
    // Create a Program to represent the project, then pull out the
    // source file to parse its AST.
    context.declaration.set(file, file);
    let program = ts.createProgram([file], {allowJs: true});
    const sourceFile = program.getSourceFile(file);

    // Loop through the root AST nodes of the file
    let content = `/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2024. All rights reserved.
 * Generated by the Cloud Object compiler. DO NOT EDIT!
 */\n`;
    let exportSpecifiers = [];
    if (isCloudObjectEntryModule(file)) {
        if (useCallFunction) {
            content += `import { ${callMethod} } from './${callFunctionUtil}';\n`;
        } else {
            content += `import type { CloudObjectLikely } from '../${importObjectName}';\n`;
        }
    }
    ts.forEachChild(sourceFile, node => {
        if (ts.isImportDeclaration(node)) {
            analyzeDependency(node, file, context);
            content += printer.printNode(ts.EmitHint.Unspecified, node, sourceFile) + '\n';
        } else if (ts.isClassDeclaration(node)) {
            // declare class修改成interface
            if (node.name.text === handler) {
                if (useCallFunction) {
                    content += '\n' + modifyDeclaredHandlerClass(node, printer, sourceFile) + '\n';
                    content += '\n' + generateImplementation() + '\n';
                    content += '\n' + exportInstance() + '\n\n';
                } else {
                    content += '\n' + generateImplementationClass(node, sourceFile) + '\n';
                }
            } else {
                content += modifyDeclaredDependenceClass(node, printer, sourceFile) + '\n';
            }
        } else if (ts.isExportDeclaration(node)) {
            node.exportClause.forEachChild(exportNode => {
                exportSpecifiers.push(exportNode);
            })
        } else {
            content += printer.printNode(ts.EmitHint.Unspecified, node, sourceFile) + '\n';
        }
    })
    if (exportSpecifiers.length > 0) {
        let exportDeclaration = factory.createExportDeclaration(
            undefined,
            false,
            factory.createNamedExports(exportSpecifiers),
            undefined,
            undefined
        );
        content += printer.printNode(ts.EmitHint.Unspecified, exportDeclaration, sourceFile) + '\n';
    }
    writeFile(file, content);
}

function parseFunctionConfig(modulePath: string) {
    try {
        let functionConfigPath = path.join(modulePath, `function-config.json`);
        let functionConfigContent = fs.readFileSync(functionConfigPath, 'utf8');
        let functionConfig = JSON.parse(functionConfigContent);
        if (!functionConfig.hasOwnProperty('handler')) {
            console.error(`Get function-config handler properties failed!.`);
            process.exit(-1);
        }
        let [moduleName, handler] = functionConfig.handler.split('.');
        console.info(`moduleName: ${moduleName}, handler: ${handler}`);
        return [moduleName.charAt(0).toUpperCase() + moduleName.slice(1), handler];
    } catch (e) {
        console.error(`parse function-config.json file failed!`, e);
        process.exit(-1);
    }
}

function checkIsDirectory(dirPath: string) {
    let stats = fs.lstatSync(dirPath);
    if (!stats.isDirectory()) {
        console.error(`File at ${dirPath} is not a directory.`);
        process.exit(-1);
    }
}

function fileExists(path: string): boolean {
    try {
        fs.accessSync(path);
        return true;
    } catch (error) {
        return false;
    }
}

function removeDir(dir) {
    let files = fs.readdirSync(dir)
    for (const file of files) {
        let newPath = path.join(dir, file);
        if (fs.statSync(newPath).isDirectory()) {
            removeDir(newPath);
        } else {
            fs.unlinkSync(newPath);
        }
    }
    fs.rmdirSync(dir)
}

function isUpperCase(ch) {
    return ch >= 'A' && ch <= 'Z'
}

function getCallFunctionModule(methods: string, print = ['', '', '']) {
    return `/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2024. All rights reserved.
 * Generated by the Cloud Object compiler. DO NOT EDIT!
 */
import { BusinessError } from '@kit.BasicServicesKit';
import { cloudFunction } from '@kit.CloudFoundationKit';
${print[0]}
const cloudObject = '${cloudObjectName}';
type methodType = ${methods};

interface callParameter {
    method: methodType
    params?: Object[]
}

function call(params: callParameter): Promise<Object> {
    return new Promise<Object>((resolve, reject) => {
        let input = {
            name: cloudObject,
            params: params
        };
        ${print[1]}
        cloudFunction.call(input).then((value: cloudFunction.FunctionResult) => {
            ${print[2]}resolve(value.result);
        }).catch((err: BusinessError) => {
            reject(err);
        })
    });
}

export { call, callParameter, cloudObject, methodType };`;
}

function getImportObjectModule(printLog = '') {
    return `/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2024. All rights reserved.
 * Generated by the Cloud Object compiler. DO NOT EDIT!
 */
import type { BusinessError } from '@kit.BasicServicesKit';
import { cloudFunction } from '@kit.CloudFoundationKit';

export interface CloudObjectLikely {
  name: string;
}

function mockMethod<T extends CloudObjectLikely>(target: T, version: string,
  prop: string | symbol): (...args: unknown[]) => Promise<unknown> {
  return async (...args: unknown[]) => new Promise((resolve, reject) => {
    cloudFunction.call({
      name: target.name,
      version: version,
      data: {
        method: prop,
        params: args
      }
    }).then((value: cloudFunction.FunctionResult) => {
      resolve(value.result);
    }).catch((err: BusinessError) => {
      reject(err);
    });
  });
}

export function importObject<T extends CloudObjectLikely>(tClass: new () => T, version = '$latest'): T {
  return new Proxy<T>(new tClass(), {
    get(target, prop): (...args: unknown[]) => Promise<unknown> {
      return mockMethod<T>(target, version, prop);
    }
  });
}
`
}
